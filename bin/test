#!/usr/bin/env ruby -w
# frozen_string_literal: true

$LOAD_PATH.unshift File.expand_path("../lib", __dir__)
$LOAD_PATH.unshift File.expand_path("../test", __dir__)

# janky way to avoid opt parsing
files, argv = ARGV.map{ [Dir["test/**/*#{it}*.rb"], it] }.partition{ it.first.any? }
files = files.map(&:first).flatten
files = Dir["test/**/*.rb"] if files.empty?
ARGV.replace(argv.map(&:last))
def opt!(*xs) = xs.flatten.map{ ARGV.delete it }.any?

require "minitest/reporters"
require "minitest/debugger"  if opt! %w[ -d --debug --debugger ]
require "minitest/fail_fast" if opt! %w[ -f --fail-fast ]
$VERBOSE = true if opt! %w[ -w --warnings ]
if opt! %w[ -c --color ]
  # Minitest::Reporters.use! Minitest::Reporters::SpecReporter.new
  Minitest::Reporters.use! Minitest::Reporters::DefaultReporter.new(color: true)
end

# this reporter prints just the failed test file/methods, and cmd to run each file
Minitest::Reporters.use!(
  Class.new(Minitest::Reporters::BaseReporter) do
    def start
      @fails = Hash.new{|h, k| h[k] = [] }
    end

    def record(r)
      return unless r.failure
      file = r.source_location&.first
      name = r.name
      @fails[file] << name
    end

    def report
      @fails.map do |f,fns|
        n = File.basename f, ".rb"
        puts n
        puts fns.map{ "  - " + it.sub(/^test_/, '').gsub(?_, ' ') }
        n
      end.each do |n|
        puts "bin/test #{n}"
      end
    end
  end.new
) if opt! %w[ -l --list ]

require "minitest/autorun"

files.each{ require_relative "../#{it}" }
