# frozen_string_literal: true

require_relative "test_helper"

class TestUnpaint < Minitest::Test
  using Gouache::Wrap

  def setup
    @go = Gouache.new
  end

  def test_class_unpaint_plain_text
    # Plain text without any escape codes should pass through unchanged
    result = Gouache.unpaint("plain text")
    assert_equal "plain text", result
  end

  def test_instance_unpaint_plain_text
    # Instance method should behave identically to class method
    result = @go.unpaint("plain text")
    assert_equal "plain text", result
  end

  def test_class_unpaint_removes_sgr_codes
    # All SGR codes should be stripped from text
    styled = "before \e[31mred\e[39m middle \e[1mbold\e[22m after"
    result = Gouache.unpaint(styled)
    assert_equal "before red middle bold after", result
  end

  def test_instance_unpaint_removes_sgr_codes
    # Instance method should strip SGR codes identically
    styled = "before \e[31mred\e[39m middle \e[1mbold\e[22m after"
    result = @go.unpaint(styled)
    assert_equal "before red middle bold after", result
  end

  def test_unpaint_removes_complex_sgr_sequences
    # Complex multi-parameter SGR codes should be removed
    complex = "text \e[1;31;4mbold red underline\e[22;39;24m normal"
    result = Gouache.unpaint(complex)
    assert_equal "text bold red underline normal", result
  end

  def test_unpaint_removes_256_color_codes
    # 256-color SGR codes should be stripped
    color256 = "text \e[38;5;196mbright red\e[39m normal"
    result = Gouache.unpaint(color256)
    assert_equal "text bright red normal", result
  end

  def test_unpaint_removes_truecolor_codes
    # Truecolor (RGB) SGR codes should be stripped
    truecolor = "text \e[38;2;255;128;0morange\e[39m normal"
    result = Gouache.unpaint(truecolor)
    assert_equal "text orange normal", result
  end

  def test_unpaint_removes_background_colors
    # Background color SGR codes should be stripped
    bg_colors = "text \e[41;103mred bg yellow bg\e[49m normal"
    result = Gouache.unpaint(bg_colors)
    assert_equal "text red bg yellow bg normal", result
  end

  def test_unpaint_removes_wrap_markers
    # Wrap open/close markers should be stripped
    wrapped = "before#{Gouache::WRAP_OPEN}wrapped content#{Gouache::WRAP_CLOSE}after"
    result = Gouache.unpaint(wrapped)
    assert_equal "beforewrapped contentafter", result
  end

  def test_unpaint_removes_sgr_and_wraps_together
    # Both SGR codes and wrap markers should be removed simultaneously
    content = "styled \e[31mred\e[39m content"
    mixed = "before#{Gouache::WRAP_OPEN}#{content}#{Gouache::WRAP_CLOSE} \e[1mbold\e[22m after"
    result = Gouache.unpaint(mixed)
    assert_equal "beforestyled red content bold after", result
  end

  def test_unpaint_with_gouache_generated_content
    # Content generated by Gouache should strip cleanly
    styled_content = @go[:red, "red text", :bold, "bold text"]
    result = Gouache.unpaint(styled_content)
    assert_equal "red textbold text", result
  end

  def test_unpaint_with_builder_generated_content
    # Content from builder methods should strip cleanly
    builder_content = @go.red.bold("styled content")
    result = @go.unpaint(builder_content)
    assert_equal "styled content", result
  end

  def test_unpaint_with_wrapped_content
    # Manually wrapped content should have wraps and SGR codes removed
    content_with_sgr = "wrapped \e[32mgreen\e[39m text"
    wrapped_content = content_with_sgr.wrap
    result = Gouache.unpaint("before #{wrapped_content} after")
    assert_equal "before wrapped green text after", result
  end

  def test_unpaint_nested_wrapped_content
    # Multiple levels of wrapping should be stripped
    inner = "inner \e[35mmagenta\e[39m text"
    middle = "middle #{inner.wrap} text"
    outer = "outer #{middle.wrap} text"
    result = Gouache.unpaint(outer)
    assert_equal "outer middle inner magenta text text text", result
  end

  def test_unpaint_preserves_non_sgr_escapes
    # Non-SGR escape sequences should be preserved
    cursor_codes = "line1\e[2Jclear\e[H home\e[s save"
    result = Gouache.unpaint(cursor_codes)
    assert_equal cursor_codes, result  # Cursor codes preserved
  end

  def test_unpaint_incomplete_escape_sequences
    # Incomplete escape sequences should be preserved
    incomplete = "text \e[31 incomplete \e[ empty"
    result = Gouache.unpaint(incomplete)
    assert_equal incomplete, result  # Incomplete escapes preserved
  end

  def test_unpaint_only_sgr_codes
    # String with only SGR codes should become empty
    only_sgr = "\e[31m\e[1m\e[39m\e[22m"
    result = Gouache.unpaint(only_sgr)
    assert_equal "", result
  end

  def test_unpaint_only_wrap_markers
    # String with only wrap markers should become empty
    only_wraps = "#{Gouache::WRAP_OPEN}#{Gouache::WRAP_CLOSE}"
    result = Gouache.unpaint(only_wraps)
    assert_equal "", result
  end

  def test_unpaint_mixed_valid_invalid_escapes
    # Mix of SGR codes and non-SGR escapes
    mixed = "text \e[31mred\e[39m \e[2J clear \e[1mbold\e[22m"
    result = Gouache.unpaint(mixed)
    assert_equal "text red \e[2J clear bold", result  # Only SGR removed
  end

  def test_unpaint_empty_string
    # Empty string should remain empty
    result = Gouache.unpaint("")
    assert_equal "", result
  end

  def test_unpaint_whitespace_only
    # Whitespace-only strings should be preserved
    whitespace = "   \n\t  "
    result = Gouache.unpaint(whitespace)
    assert_equal whitespace, result
  end

  def test_unpaint_unicode_text
    # Unicode text should be preserved while SGR codes are removed
    unicode_sgr = "emoji 游깯 \e[31mred\e[39m 침o침o text"
    result = Gouache.unpaint(unicode_sgr)
    assert_equal "emoji 游깯 red 침o침o text", result
  end

  def test_class_vs_instance_method_consistency
    # Class and instance methods should produce identical results
    test_cases = [
      "plain text",
      "\e[31mred\e[39m text",
      "wrap#{Gouache::WRAP_OPEN}content#{Gouache::WRAP_CLOSE}end",
      @go[:bold, "bold text"],
      @go.red.italic("styled"),
      "mixed \e[1mbold\e[22m #{Gouache::WRAP_OPEN}wrapped#{Gouache::WRAP_CLOSE}"
    ]

    test_cases.each do |test_string|
      class_result = Gouache.unpaint(test_string)
      instance_result = @go.unpaint(test_string)
      assert_equal class_result, instance_result, "Mismatch for: #{test_string.inspect}"
    end
  end

  def test_unpaint_extremely_long_string
    # Performance test with long string containing many SGR codes
    long_parts = Array.new(1000) { |i| "part#{i}\e[3#{i%8}m\e[39m" }
    long_string = long_parts.join(" ")
    result = Gouache.unpaint(long_string)

    # Should contain no SGR codes
    refute_includes result, "\e[3"
    refute_includes result, "\e[39m"
    assert_includes result, "part0"
    assert_includes result, "part999"
  end

  def test_unpaint_with_repaint_roundtrip
    # Text processed by repaint should unpaint cleanly
    original = "text with \e[31mred\e[0m content"
    repainted = @go.repaint(original)
    unpainted = Gouache.unpaint(repainted)
    assert_equal "text with red content", unpainted
  end

  def test_unpaint_complex_nested_structure
    # Complex nested structure with multiple styling methods
    complex = @go[
      "start ",
      [:bold, "bold#{Gouache::WRAP_OPEN}\e[31mwrapped red\e[39m#{Gouache::WRAP_CLOSE}"],
      " middle ",
      @go.italic("italic text"),
      " end"
    ]
    result = Gouache.unpaint(complex)
    assert_equal "start boldwrapped red middle italic text end", result
  end

  def test_unpaint_all_basic_colors
    # Test removal of all 8 basic colors (30-37)
    all_colors = (30..37).map { |i| "\e[#{i}mcolor#{i}\e[39m" }.join(" ")
    result = Gouache.unpaint("start #{all_colors} end")
    expected = "start color30 color31 color32 color33 color34 color35 color36 color37 end"
    assert_equal expected, result
  end

  def test_unpaint_all_basic_backgrounds
    # Test removal of all 8 basic background colors (40-47)
    all_bg = (40..47).map { |i| "\e[#{i}mbg#{i}\e[49m" }.join(" ")
    result = Gouache.unpaint("start #{all_bg} end")
    expected = "start bg40 bg41 bg42 bg43 bg44 bg45 bg46 bg47 end"
    assert_equal expected, result
  end

  def test_unpaint_all_text_attributes
    # Test removal of common text attributes (bold, italic, underline, etc.)
    attrs = [
      "\e[1mbold\e[22m",
      "\e[2mdim\e[22m",
      "\e[3mitalic\e[23m",
      "\e[4munderline\e[24m",
      "\e[9mstrike\e[29m"
    ].join(" ")
    result = Gouache.unpaint("start #{attrs} end")
    assert_equal "start bold dim italic underline strike end", result
  end

  def test_unpaint_custom_gouache_instance
    # unpaint should work regardless of custom styles in instance
    custom_go = Gouache.new(custom_red: 91, custom_blue: 94)
    styled = custom_go[:custom_red, "red text", :custom_blue, "blue text"]
    result = custom_go.unpaint(styled)
    assert_equal "red textblue text", result
  end
end
