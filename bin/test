#!/usr/bin/env ruby -w
# frozen_string_literal: true

$LOAD_PATH.unshift File.expand_path("../lib", __dir__)
$LOAD_PATH.unshift File.expand_path("../test", __dir__)

argv, files = ARGV.partition { it.start_with? ?- }  # Separate file args from minitest args
ARGV.replace(argv)                                  # Set ARGV to minitest args only

require "minitest/reporters"
require "minitest/debugger"  if (ARGV & %w[ -d --debug --debugger ]).any?
require "minitest/fail_fast" if (ARGV & %w[ -f --fail-fast ]).any?
$VERBOSE = true if (ARGV & %w[ -w --warnings ]).any?
if (ARGV & %w[ -c --color ]).any?
  # Minitest::Reporters.use! Minitest::Reporters::SpecReporter.new
  Minitest::Reporters.use! Minitest::Reporters::DefaultReporter.new(color: true)
end

# this reporter prints just the failed test file/methods, and cmd to run each file
Minitest::Reporters.use!(
  Class.new(Minitest::Reporters::BaseReporter) do
    def start
      @fails = Hash.new{|h, k| h[k] = [] }
    end

    def record(r)
      return unless r.failure
      file = r.source_location&.first
      name = r.name
      @fails[file] << name
    end

    def report
      @fails.map do |f,fns|
        n = File.basename f, ".rb"
        puts n
        puts fns.map{ "  - " + it.sub(/^test_/, '').gsub(?_, ' ') }
        n
      end.each do |n|
        puts "bin/test #{n}"
      end
    end
  end.new
) if (ARGV & %w[ -l --list ]).any?


require "minitest/autorun"

files.map!{ "*#{it}*" }
files = ["*"] if files.empty?
files.flat_map{ Dir["test/**/*#{it}*.rb"] }.each{ require_relative "../#{it}" }
